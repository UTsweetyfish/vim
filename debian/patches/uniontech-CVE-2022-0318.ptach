Index: vim/src/ops.c
===================================================================
--- vim.orig/src/ops.c
+++ vim/src/ops.c
@@ -529,30 +529,14 @@ block_insert(
 	}
 
 	if (has_mbyte && spaces > 0)
-	{
-	    int off;
-
-	    // Avoid starting halfway a multi-byte character.
-	    if (b_insert)
-	    {
-		off = (*mb_head_off)(oldp, oldp + offset + spaces);
-		spaces -= off;
-		count -= off;
-	    }
-	    else
-	    {
-		// spaces fill the gap, the character that's at the edge moves
-		// right
-		off = (*mb_head_off)(oldp, oldp + offset);
-		offset -= off;
-	    }
-	}
+	    // avoid copying part of a multi-byte character
+	    offset -= (*mb_head_off)(oldp, oldp + offset);
 	if (spaces < 0)  // can happen when the cursor was moved
 	    spaces = 0;
 
 	// Make sure the allocated size matches what is actually copied below.
 	newp = alloc(STRLEN(oldp) + spaces + s_len
-		    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)
+		    + (spaces > 0 && !bdp->is_short ? p_ts - spaces : 0)
 				  + count + 1);
 	if (newp == NULL)
 	    continue;
@@ -575,7 +559,7 @@ block_insert(
 	    {
 	    // insert post-padding
 	    vim_memset(newp + offset + spaces, ' ',
-					(size_t)(ts_val - spaces));
+				    (size_t)(p_ts - spaces));
 	    // we're splitting a TAB, don't copy it
 	    oldp++;
 	    // We allowed for that TAB, remember this now
Index: vim/src/testdir/test_visual.vim
===================================================================
--- vim.orig/src/testdir/test_visual.vim
+++ vim/src/testdir/test_visual.vim
@@ -402,6 +402,15 @@ func Test_visual_block_append_invalid_ch
   bwipe!
 endfunc
 
+func Test_visual_block_insert_round_off()
+  new
+  " The number of characters are tuned to fill a 4096 byte allocated block,
+  " so that valgrind reports going over the end.
+  call setline(1, ['xxxxx', repeat('0', 1350), "\t", repeat('x', 60)])
+  exe "normal gg0\<C-V>GI" .. repeat('0', 1320) .. "\<Esc>"
+  bwipe!
+endfunc
+
 func Test_Visual_paragraph_textobject()
   new
   let lines =<< trim [END]
