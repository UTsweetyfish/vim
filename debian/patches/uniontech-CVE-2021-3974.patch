Index: vim/src/regexp.c
===================================================================
--- vim.orig/src/regexp.c
+++ vim/src/regexp.c
@@ -1129,7 +1129,7 @@ typedef struct {
     // The current match-position is stord in these variables:
     linenr_T	lnum;		// line number, relative to first line
     char_u	*line;		// start of current line
-    char_u	*input;		// current input, points into "regline"
+    char_u	*input;		// current input, points into "line"
 
     int	need_clear_subexpr;	// subexpressions still need to be cleared
 #ifdef FEAT_SYN_HL
Index: vim/src/regexp_nfa.c
===================================================================
--- vim.orig/src/regexp_nfa.c
+++ vim/src/regexp_nfa.c
@@ -6835,7 +6835,14 @@ nfa_regmatch(
 	    case NFA_MARK_LT:
 	      {
 		pos_T	*pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);
+    		size_t	col = rex.input - rex.line;
 
+		// Line may have been freed, get it again.
+		if (REG_MULTI)
+		{
+		    rex.line = reg_getline(rex.lnum);
+		    rex.input = rex.line + col;
+		}
 		// Compare the mark position to the match position, if the mark
 		// exists and mark is set in reg_buf.
 		if (pos != NULL && pos->lnum > 0)
Index: vim/src/testdir/test_regexp_latin.vim
===================================================================
--- vim.orig/src/testdir/test_regexp_latin.vim
+++ vim/src/testdir/test_regexp_latin.vim
@@ -88,6 +88,14 @@ func Test_multi_failure()
   set re=0
 endfunc
 
+func Test_using_mark_position()
+  " this was using freed memory
+  new
+  norm O0
+  call assert_fails("s/\\%')", 'E486:')
+  bwipe!
+endfunc
+
 func Test_recursive_addstate()
   " This will call addstate() recursively until it runs into the limit.
   let lnum = search('\v((){328}){389}')
